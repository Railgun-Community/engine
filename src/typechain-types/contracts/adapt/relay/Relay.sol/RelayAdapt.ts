/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from '../../../../common';

export type TokenDataStruct = {
  tokenType: PromiseOrValue<BigNumberish>;
  tokenAddress: PromiseOrValue<string>;
  tokenSubID: PromiseOrValue<BigNumberish>;
};

export type TokenDataStructOutput = [number, string, BigNumber] & {
  tokenType: number;
  tokenAddress: string;
  tokenSubID: BigNumber;
};

export type G1PointStruct = {
  x: PromiseOrValue<BigNumberish>;
  y: PromiseOrValue<BigNumberish>;
};

export type G1PointStructOutput = [BigNumber, BigNumber] & {
  x: BigNumber;
  y: BigNumber;
};

export type G2PointStruct = {
  x: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  y: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
};

export type G2PointStructOutput = [[BigNumber, BigNumber], [BigNumber, BigNumber]] & {
  x: [BigNumber, BigNumber];
  y: [BigNumber, BigNumber];
};

export type SnarkProofStruct = {
  a: G1PointStruct;
  b: G2PointStruct;
  c: G1PointStruct;
};

export type SnarkProofStructOutput = [
  G1PointStructOutput,
  G2PointStructOutput,
  G1PointStructOutput,
] & { a: G1PointStructOutput; b: G2PointStructOutput; c: G1PointStructOutput };

export type CommitmentCiphertextStruct = {
  ciphertext: [
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
  ];
  ephemeralKeys: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  memo: PromiseOrValue<BigNumberish>[];
};

export type CommitmentCiphertextStructOutput = [
  [BigNumber, BigNumber, BigNumber, BigNumber],
  [BigNumber, BigNumber],
  BigNumber[],
] & {
  ciphertext: [BigNumber, BigNumber, BigNumber, BigNumber];
  ephemeralKeys: [BigNumber, BigNumber];
  memo: BigNumber[];
};

export type BoundParamsStruct = {
  treeNumber: PromiseOrValue<BigNumberish>;
  withdraw: PromiseOrValue<BigNumberish>;
  adaptContract: PromiseOrValue<string>;
  adaptParams: PromiseOrValue<BytesLike>;
  commitmentCiphertext: CommitmentCiphertextStruct[];
};

export type BoundParamsStructOutput = [
  number,
  number,
  string,
  string,
  CommitmentCiphertextStructOutput[],
] & {
  treeNumber: number;
  withdraw: number;
  adaptContract: string;
  adaptParams: string;
  commitmentCiphertext: CommitmentCiphertextStructOutput[];
};

export type CommitmentPreimageStruct = {
  npk: PromiseOrValue<BigNumberish>;
  token: TokenDataStruct;
  value: PromiseOrValue<BigNumberish>;
};

export type CommitmentPreimageStructOutput = [BigNumber, TokenDataStructOutput, BigNumber] & {
  npk: BigNumber;
  token: TokenDataStructOutput;
  value: BigNumber;
};

export type TransactionStruct = {
  proof: SnarkProofStruct;
  merkleRoot: PromiseOrValue<BigNumberish>;
  nullifiers: PromiseOrValue<BigNumberish>[];
  commitments: PromiseOrValue<BigNumberish>[];
  boundParams: BoundParamsStruct;
  withdrawPreimage: CommitmentPreimageStruct;
  overrideOutput: PromiseOrValue<string>;
};

export type TransactionStructOutput = [
  SnarkProofStructOutput,
  BigNumber,
  BigNumber[],
  BigNumber[],
  BoundParamsStructOutput,
  CommitmentPreimageStructOutput,
  string,
] & {
  proof: SnarkProofStructOutput;
  merkleRoot: BigNumber;
  nullifiers: BigNumber[];
  commitments: BigNumber[];
  boundParams: BoundParamsStructOutput;
  withdrawPreimage: CommitmentPreimageStructOutput;
  overrideOutput: string;
};

export declare namespace RelayAdapt {
  export type ResultStruct = {
    success: PromiseOrValue<boolean>;
    returnData: PromiseOrValue<string>;
  };

  export type ResultStructOutput = [boolean, string] & {
    success: boolean;
    returnData: string;
  };

  export type CallStruct = {
    to: PromiseOrValue<string>;
    data: PromiseOrValue<BytesLike>;
    value: PromiseOrValue<BigNumberish>;
  };

  export type CallStructOutput = [string, string, BigNumber] & {
    to: string;
    data: string;
    value: BigNumber;
  };
}

export interface RelayAdaptInterface extends utils.Interface {
  functions: {
    'VERIFICATION_BYPASS()': FunctionFragment;
    'deposit((uint8,address,uint256)[],uint256[2],uint256)': FunctionFragment;
    'getAdaptParams((((uint256,uint256),(uint256[2],uint256[2]),(uint256,uint256)),uint256,uint256[],uint256[],(uint16,uint8,address,bytes32,(uint256[4],uint256[2],uint256[])[]),(uint256,(uint8,address,uint256),uint120),address)[],bytes)': FunctionFragment;
    'getRelayAdaptParams((((uint256,uint256),(uint256[2],uint256[2]),(uint256,uint256)),uint256,uint256[],uint256[],(uint16,uint8,address,bytes32,(uint256[4],uint256[2],uint256[])[]),(uint256,(uint8,address,uint256),uint120),address)[],uint256,bool,uint256,(address,bytes,uint256)[])': FunctionFragment;
    'railgun()': FunctionFragment;
    'railgunBatch((((uint256,uint256),(uint256[2],uint256[2]),(uint256,uint256)),uint256,uint256[],uint256[],(uint16,uint8,address,bytes32,(uint256[4],uint256[2],uint256[])[]),(uint256,(uint8,address,uint256),uint120),address)[],bytes)': FunctionFragment;
    'relay((((uint256,uint256),(uint256[2],uint256[2]),(uint256,uint256)),uint256,uint256[],uint256[],(uint16,uint8,address,bytes32,(uint256[4],uint256[2],uint256[])[]),(uint256,(uint8,address,uint256),uint120),address)[],uint256,bool,uint256,(address,bytes,uint256)[])': FunctionFragment;
    'send((uint8,address,uint256)[],address)': FunctionFragment;
    'unwrapAllBase()': FunctionFragment;
    'wbase()': FunctionFragment;
    'wrapAllBase()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'VERIFICATION_BYPASS'
      | 'deposit'
      | 'getAdaptParams'
      | 'getRelayAdaptParams'
      | 'railgun'
      | 'railgunBatch'
      | 'relay'
      | 'send'
      | 'unwrapAllBase'
      | 'wbase'
      | 'wrapAllBase',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'VERIFICATION_BYPASS', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [
      TokenDataStruct[],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'getAdaptParams',
    values: [TransactionStruct[], PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getRelayAdaptParams',
    values: [
      TransactionStruct[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      RelayAdapt.CallStruct[],
    ],
  ): string;
  encodeFunctionData(functionFragment: 'railgun', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'railgunBatch',
    values: [TransactionStruct[], PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'relay',
    values: [
      TransactionStruct[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      RelayAdapt.CallStruct[],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'send',
    values: [TokenDataStruct[], PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'unwrapAllBase', values?: undefined): string;
  encodeFunctionData(functionFragment: 'wbase', values?: undefined): string;
  encodeFunctionData(functionFragment: 'wrapAllBase', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'VERIFICATION_BYPASS', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getAdaptParams', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRelayAdaptParams', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'railgun', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'railgunBatch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'relay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'send', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unwrapAllBase', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'wbase', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'wrapAllBase', data: BytesLike): Result;

  events: {
    'CallResult(tuple[])': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'CallResult'): EventFragment;
}

export interface CallResultEventObject {
  callResults: RelayAdapt.ResultStructOutput[];
}
export type CallResultEvent = TypedEvent<[RelayAdapt.ResultStructOutput[]], CallResultEventObject>;

export type CallResultEventFilter = TypedEventFilter<CallResultEvent>;

export interface RelayAdapt extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: RelayAdaptInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | Optional<number>,
    toBlock?: string | Optional<number>,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>,
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    VERIFICATION_BYPASS(overrides?: CallOverrides): Promise<[string]>;

    deposit(
      _deposits: TokenDataStruct[],
      _encryptedRandom: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _npk: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getAdaptParams(
      _transactions: TransactionStruct[],
      _additionalData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    getRelayAdaptParams(
      _transactions: TransactionStruct[],
      _random: PromiseOrValue<BigNumberish>,
      _requireSuccess: PromiseOrValue<boolean>,
      _minGas: PromiseOrValue<BigNumberish>,
      _calls: RelayAdapt.CallStruct[],
      overrides?: CallOverrides,
    ): Promise<[string]>;

    railgun(overrides?: CallOverrides): Promise<[string]>;

    railgunBatch(
      _transactions: TransactionStruct[],
      _additionalData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    relay(
      _transactions: TransactionStruct[],
      _random: PromiseOrValue<BigNumberish>,
      _requireSuccess: PromiseOrValue<boolean>,
      _minGas: PromiseOrValue<BigNumberish>,
      _calls: RelayAdapt.CallStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    send(
      _tokens: TokenDataStruct[],
      _to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    unwrapAllBase(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    wbase(overrides?: CallOverrides): Promise<[string]>;

    wrapAllBase(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  VERIFICATION_BYPASS(overrides?: CallOverrides): Promise<string>;

  deposit(
    _deposits: TokenDataStruct[],
    _encryptedRandom: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    _npk: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getAdaptParams(
    _transactions: TransactionStruct[],
    _additionalData: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<string>;

  getRelayAdaptParams(
    _transactions: TransactionStruct[],
    _random: PromiseOrValue<BigNumberish>,
    _requireSuccess: PromiseOrValue<boolean>,
    _minGas: PromiseOrValue<BigNumberish>,
    _calls: RelayAdapt.CallStruct[],
    overrides?: CallOverrides,
  ): Promise<string>;

  railgun(overrides?: CallOverrides): Promise<string>;

  railgunBatch(
    _transactions: TransactionStruct[],
    _additionalData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  relay(
    _transactions: TransactionStruct[],
    _random: PromiseOrValue<BigNumberish>,
    _requireSuccess: PromiseOrValue<boolean>,
    _minGas: PromiseOrValue<BigNumberish>,
    _calls: RelayAdapt.CallStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  send(
    _tokens: TokenDataStruct[],
    _to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  unwrapAllBase(
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  wbase(overrides?: CallOverrides): Promise<string>;

  wrapAllBase(
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    VERIFICATION_BYPASS(overrides?: CallOverrides): Promise<string>;

    deposit(
      _deposits: TokenDataStruct[],
      _encryptedRandom: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _npk: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    getAdaptParams(
      _transactions: TransactionStruct[],
      _additionalData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    getRelayAdaptParams(
      _transactions: TransactionStruct[],
      _random: PromiseOrValue<BigNumberish>,
      _requireSuccess: PromiseOrValue<boolean>,
      _minGas: PromiseOrValue<BigNumberish>,
      _calls: RelayAdapt.CallStruct[],
      overrides?: CallOverrides,
    ): Promise<string>;

    railgun(overrides?: CallOverrides): Promise<string>;

    railgunBatch(
      _transactions: TransactionStruct[],
      _additionalData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    relay(
      _transactions: TransactionStruct[],
      _random: PromiseOrValue<BigNumberish>,
      _requireSuccess: PromiseOrValue<boolean>,
      _minGas: PromiseOrValue<BigNumberish>,
      _calls: RelayAdapt.CallStruct[],
      overrides?: CallOverrides,
    ): Promise<void>;

    send(
      _tokens: TokenDataStruct[],
      _to: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    unwrapAllBase(overrides?: CallOverrides): Promise<void>;

    wbase(overrides?: CallOverrides): Promise<string>;

    wrapAllBase(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    'CallResult(tuple[])'(callResults?: null): CallResultEventFilter;
    CallResult(callResults?: null): CallResultEventFilter;
  };

  estimateGas: {
    VERIFICATION_BYPASS(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      _deposits: TokenDataStruct[],
      _encryptedRandom: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _npk: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getAdaptParams(
      _transactions: TransactionStruct[],
      _additionalData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getRelayAdaptParams(
      _transactions: TransactionStruct[],
      _random: PromiseOrValue<BigNumberish>,
      _requireSuccess: PromiseOrValue<boolean>,
      _minGas: PromiseOrValue<BigNumberish>,
      _calls: RelayAdapt.CallStruct[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    railgun(overrides?: CallOverrides): Promise<BigNumber>;

    railgunBatch(
      _transactions: TransactionStruct[],
      _additionalData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    relay(
      _transactions: TransactionStruct[],
      _random: PromiseOrValue<BigNumberish>,
      _requireSuccess: PromiseOrValue<boolean>,
      _minGas: PromiseOrValue<BigNumberish>,
      _calls: RelayAdapt.CallStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    send(
      _tokens: TokenDataStruct[],
      _to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    unwrapAllBase(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    wbase(overrides?: CallOverrides): Promise<BigNumber>;

    wrapAllBase(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;
  };

  populateTransaction: {
    VERIFICATION_BYPASS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      _deposits: TokenDataStruct[],
      _encryptedRandom: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      _npk: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getAdaptParams(
      _transactions: TransactionStruct[],
      _additionalData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getRelayAdaptParams(
      _transactions: TransactionStruct[],
      _random: PromiseOrValue<BigNumberish>,
      _requireSuccess: PromiseOrValue<boolean>,
      _minGas: PromiseOrValue<BigNumberish>,
      _calls: RelayAdapt.CallStruct[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    railgun(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    railgunBatch(
      _transactions: TransactionStruct[],
      _additionalData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    relay(
      _transactions: TransactionStruct[],
      _random: PromiseOrValue<BigNumberish>,
      _requireSuccess: PromiseOrValue<boolean>,
      _minGas: PromiseOrValue<BigNumberish>,
      _calls: RelayAdapt.CallStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    send(
      _tokens: TokenDataStruct[],
      _to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    unwrapAllBase(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    wbase(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wrapAllBase(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}
